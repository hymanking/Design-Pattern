package com.ifsaid.prototype;

/**
 * @Program: Design-Pattern
 * @Description: 原型设计模式
 * @Author:
 * 这种不通过 new 关键字来产生一个对象，而是通过对象拷贝来实现的模式就叫做原型模式，
 * 这个模式的核心是一个clone( )方法，通过这个方法进行对象的拷贝，
 * Java 提供了一个 Cloneable 接口来标示这个对象是可拷贝的，为什么说是“标示”呢？
 * 翻开 JDK 的帮助看看 Cloneable 是一个方法都没有的，
 * 这个接口只是一个标记作用，在 JVM 中具有这个标记的对象才有可能被拷贝，
 * 所以覆盖了覆盖clone()方法就可以了。
 * 在 clone()方法上增加了一个注解@Override，
 * 没有继承一个类为什么可以重写呢？在 Java 中所有类的父类是Object 类，
 * 每个类默认都是继承了这个类，所以这个用上@Override是非常正确的。
 * 原型模式虽然很简单，但是在 Java 中使用原型模式也就是 clone 方法还是
 * 有一些注意事项的：
 * 对象拷贝时，类的构造函数是不会被执行的。 一个实现了 Cloneable 并重写了 clone 方法的类
 * A,有一个无参构造或有参构造 B，通过 new 关键字产生了一个对象 S，
 * 再然后通过 S.clone()方式产生了一个新的对象 T，
 * 那么在对象拷贝时构造函数 B 是不会被执行的，
 * 对象拷贝时确实构造函数没有被执行，这个从原理来讲也是可以讲得通的，
 * Object 类的 clone 方法的 原理是从内存中（具体的说就是堆内存）以二进制流的方式进行拷贝，
 * 重新分配一个内存块，那构造函数 没有被执行也是非常正常的了。
 *
 *
 * 浅度克隆，
 * 当被克隆的类中有引用对象（String或Integer等包装类型除外）时，
 * 克隆出来的类中的引用变量存储的还是之前的内存地址，也就是说克隆与被克隆的对象是同一个。
 * 这样的话两个对象共享了一个私有变量，所有人都可以改，是一个种非常不安全的方式，
 * 在实际项目中使用还是比较少的。
 *
 * 这样就完成了深度拷贝，两种对象互为独立，属于单独对象。
　　注意：final 类型修饰的成员变量不能进行深度拷贝　　
　　最后说一下，原型模式的使用场景
　　1、在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。
　　2、希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。
　　3、隐藏克隆操作的细节，很多时候，对对象本身的克隆需要涉及到类本身的数据细节。
　　4、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；
　　5、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；
　　6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，
    可以考虑使用原型模式拷贝多个对象供调用者使用。在实际项目中，原型模式很少单独出现，
    一般是和工厂方法模式一起出现，通过 clone的方法创建一个对象，
    然后由工厂方法提供给调用者。原型模式先产生出一个包含
　　大量共有信息的类，然后可以拷贝出副本，修正细节信息，建立了一个完整的个性对象。

    深度克隆的实现方式是：
        如果对象中有引用类型，如 List
        就是把被克隆对象的List属性，
        完整的拷贝一份赋值给克隆对象
 *
 * @Create: 2018-08-13 20:30
 * @Version: 1.0
 **/
public class PrototypeDemo {

    public static void main(String[] args) {

        ShapeCache.loadCache();

        Shape shape1 = ShapeCache.getShape("1");
        System.out.println("shape1: " + shape1.getType());

        Shape shape2 = ShapeCache.getShape("2");
        System.out.println("shape2：" + shape2.getType());

    }

}
